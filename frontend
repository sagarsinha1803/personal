const sendMessage = async () => {
  if (!input.trim()) return;

  // Add user's message
  setMessages((prev) => [...prev, { sender: "user", text: input }]);

  const payload = {
    message: input,
    protected_mode: false,
    checkpoint_id: null,
  };

  setInput("");
  setLoading(true);

  const response = await fetch("http://localhost:8000/agent/chat_stream", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload),
  });

  const reader = response.body.getReader();
  const decoder = new TextDecoder("utf-8");

  // ðŸ”¥ Create ONE empty AI bubble
  let aiIndex = null;
  setMessages((prev) => {
    aiIndex = prev.length;
    return [...prev, { sender: "ai", text: "" }];
  });

  while (true) {
    const { value, done } = await reader.read();
    if (done) break;

    const chunk = decoder.decode(value, { stream: true });
    const lines = chunk.split("\n");

    for (let line of lines) {
      if (!line.startsWith("data:")) continue;

      const json = line.replace("data:", "").trim();
      if (!json) continue;

      let event;
      try {
        event = JSON.parse(json);
      } catch {
        continue;
      }

      // ðŸŸ¢ NORMAL AI STREAM TEXT â†’ append
      if (event.type === "message") {
        setMessages((prev) => {
          const updated = [...prev];
          updated[aiIndex].text += event.content;   // append chunk!
          return updated;
        });
      }

      // ðŸŸ£ TOOL CALL
      if (event.type === "tool_call") {
        setMessages((prev) => [
          ...prev,
          { sender: "ai", text: `ðŸ›  Tool: ${event.tool} | Args: ${JSON.stringify(event.args)}` },
        ]);
      }

      // ðŸ”´ HUMAN APPROVAL
      if (event.type === "human_approval_required") {
        setInterrupt(event.interrupt);
        setLoading(false);
        return;
      }
    }
  }

  setLoading(false);
};
